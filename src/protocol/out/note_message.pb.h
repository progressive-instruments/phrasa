// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: note_message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_note_5fmessage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_note_5fmessage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_note_5fmessage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_note_5fmessage_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_note_5fmessage_2eproto;
namespace shift_processor {
class EmptyMessage;
struct EmptyMessageDefaultTypeInternal;
extern EmptyMessageDefaultTypeInternal _EmptyMessage_default_instance_;
class EventValue;
struct EventValueDefaultTypeInternal;
extern EventValueDefaultTypeInternal _EventValue_default_instance_;
class GetStatusData;
struct GetStatusDataDefaultTypeInternal;
extern GetStatusDataDefaultTypeInternal _GetStatusData_default_instance_;
class InstrumentEvents;
struct InstrumentEventsDefaultTypeInternal;
extern InstrumentEventsDefaultTypeInternal _InstrumentEvents_default_instance_;
class RangedValue;
struct RangedValueDefaultTypeInternal;
extern RangedValueDefaultTypeInternal _RangedValue_default_instance_;
class SequenceEvent;
struct SequenceEventDefaultTypeInternal;
extern SequenceEventDefaultTypeInternal _SequenceEvent_default_instance_;
class SequenceEvent_ValuesEntry_DoNotUse;
struct SequenceEvent_ValuesEntry_DoNotUseDefaultTypeInternal;
extern SequenceEvent_ValuesEntry_DoNotUseDefaultTypeInternal _SequenceEvent_ValuesEntry_DoNotUse_default_instance_;
class SequencePosition;
struct SequencePositionDefaultTypeInternal;
extern SequencePositionDefaultTypeInternal _SequencePosition_default_instance_;
class SetPlayMode;
struct SetPlayModeDefaultTypeInternal;
extern SetPlayModeDefaultTypeInternal _SetPlayMode_default_instance_;
class SetSequenceMessage;
struct SetSequenceMessageDefaultTypeInternal;
extern SetSequenceMessageDefaultTypeInternal _SetSequenceMessage_default_instance_;
class ShiftPlayerMessage;
struct ShiftPlayerMessageDefaultTypeInternal;
extern ShiftPlayerMessageDefaultTypeInternal _ShiftPlayerMessage_default_instance_;
class ShiftPlayerResponse;
struct ShiftPlayerResponseDefaultTypeInternal;
extern ShiftPlayerResponseDefaultTypeInternal _ShiftPlayerResponse_default_instance_;
}  // namespace shift_processor
PROTOBUF_NAMESPACE_OPEN
template<> ::shift_processor::EmptyMessage* Arena::CreateMaybeMessage<::shift_processor::EmptyMessage>(Arena*);
template<> ::shift_processor::EventValue* Arena::CreateMaybeMessage<::shift_processor::EventValue>(Arena*);
template<> ::shift_processor::GetStatusData* Arena::CreateMaybeMessage<::shift_processor::GetStatusData>(Arena*);
template<> ::shift_processor::InstrumentEvents* Arena::CreateMaybeMessage<::shift_processor::InstrumentEvents>(Arena*);
template<> ::shift_processor::RangedValue* Arena::CreateMaybeMessage<::shift_processor::RangedValue>(Arena*);
template<> ::shift_processor::SequenceEvent* Arena::CreateMaybeMessage<::shift_processor::SequenceEvent>(Arena*);
template<> ::shift_processor::SequenceEvent_ValuesEntry_DoNotUse* Arena::CreateMaybeMessage<::shift_processor::SequenceEvent_ValuesEntry_DoNotUse>(Arena*);
template<> ::shift_processor::SequencePosition* Arena::CreateMaybeMessage<::shift_processor::SequencePosition>(Arena*);
template<> ::shift_processor::SetPlayMode* Arena::CreateMaybeMessage<::shift_processor::SetPlayMode>(Arena*);
template<> ::shift_processor::SetSequenceMessage* Arena::CreateMaybeMessage<::shift_processor::SetSequenceMessage>(Arena*);
template<> ::shift_processor::ShiftPlayerMessage* Arena::CreateMaybeMessage<::shift_processor::ShiftPlayerMessage>(Arena*);
template<> ::shift_processor::ShiftPlayerResponse* Arena::CreateMaybeMessage<::shift_processor::ShiftPlayerResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace shift_processor {

enum ResponseStatus : int {
  Ok = 0,
  GeneralError = 1,
  ParsingError = 2,
  InvalidInput = 3,
  ResponseStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ResponseStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ResponseStatus_IsValid(int value);
constexpr ResponseStatus ResponseStatus_MIN = Ok;
constexpr ResponseStatus ResponseStatus_MAX = InvalidInput;
constexpr int ResponseStatus_ARRAYSIZE = ResponseStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseStatus_descriptor();
template<typename T>
inline const std::string& ResponseStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseStatus_descriptor(), enum_t_value);
}
inline bool ResponseStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResponseStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseStatus>(
    ResponseStatus_descriptor(), name, value);
}
enum PlayMode : int {
  Play = 0,
  Stop = 1,
  Pause = 2,
  PlayMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlayMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlayMode_IsValid(int value);
constexpr PlayMode PlayMode_MIN = Play;
constexpr PlayMode PlayMode_MAX = Pause;
constexpr int PlayMode_ARRAYSIZE = PlayMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayMode_descriptor();
template<typename T>
inline const std::string& PlayMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayMode_descriptor(), enum_t_value);
}
inline bool PlayMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayMode>(
    PlayMode_descriptor(), name, value);
}
// ===================================================================

class ShiftPlayerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:shift_processor.ShiftPlayerMessage) */ {
 public:
  inline ShiftPlayerMessage() : ShiftPlayerMessage(nullptr) {}
  ~ShiftPlayerMessage() override;
  explicit constexpr ShiftPlayerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShiftPlayerMessage(const ShiftPlayerMessage& from);
  ShiftPlayerMessage(ShiftPlayerMessage&& from) noexcept
    : ShiftPlayerMessage() {
    *this = ::std::move(from);
  }

  inline ShiftPlayerMessage& operator=(const ShiftPlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShiftPlayerMessage& operator=(ShiftPlayerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShiftPlayerMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kSetSequence = 1,
    kSetPlayMode = 2,
    kGetPlayerState = 3,
    MESSAGE_NOT_SET = 0,
  };

  static inline const ShiftPlayerMessage* internal_default_instance() {
    return reinterpret_cast<const ShiftPlayerMessage*>(
               &_ShiftPlayerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ShiftPlayerMessage& a, ShiftPlayerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ShiftPlayerMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShiftPlayerMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShiftPlayerMessage* New() const final {
    return new ShiftPlayerMessage();
  }

  ShiftPlayerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShiftPlayerMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShiftPlayerMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShiftPlayerMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShiftPlayerMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "shift_processor.ShiftPlayerMessage";
  }
  protected:
  explicit ShiftPlayerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetSequenceFieldNumber = 1,
    kSetPlayModeFieldNumber = 2,
    kGetPlayerStateFieldNumber = 3,
  };
  // .shift_processor.SetSequenceMessage setSequence = 1;
  bool has_setsequence() const;
  private:
  bool _internal_has_setsequence() const;
  public:
  void clear_setsequence();
  const ::shift_processor::SetSequenceMessage& setsequence() const;
  PROTOBUF_MUST_USE_RESULT ::shift_processor::SetSequenceMessage* release_setsequence();
  ::shift_processor::SetSequenceMessage* mutable_setsequence();
  void set_allocated_setsequence(::shift_processor::SetSequenceMessage* setsequence);
  private:
  const ::shift_processor::SetSequenceMessage& _internal_setsequence() const;
  ::shift_processor::SetSequenceMessage* _internal_mutable_setsequence();
  public:
  void unsafe_arena_set_allocated_setsequence(
      ::shift_processor::SetSequenceMessage* setsequence);
  ::shift_processor::SetSequenceMessage* unsafe_arena_release_setsequence();

  // .shift_processor.SetPlayMode setPlayMode = 2;
  bool has_setplaymode() const;
  private:
  bool _internal_has_setplaymode() const;
  public:
  void clear_setplaymode();
  const ::shift_processor::SetPlayMode& setplaymode() const;
  PROTOBUF_MUST_USE_RESULT ::shift_processor::SetPlayMode* release_setplaymode();
  ::shift_processor::SetPlayMode* mutable_setplaymode();
  void set_allocated_setplaymode(::shift_processor::SetPlayMode* setplaymode);
  private:
  const ::shift_processor::SetPlayMode& _internal_setplaymode() const;
  ::shift_processor::SetPlayMode* _internal_mutable_setplaymode();
  public:
  void unsafe_arena_set_allocated_setplaymode(
      ::shift_processor::SetPlayMode* setplaymode);
  ::shift_processor::SetPlayMode* unsafe_arena_release_setplaymode();

  // .shift_processor.EmptyMessage getPlayerState = 3;
  bool has_getplayerstate() const;
  private:
  bool _internal_has_getplayerstate() const;
  public:
  void clear_getplayerstate();
  const ::shift_processor::EmptyMessage& getplayerstate() const;
  PROTOBUF_MUST_USE_RESULT ::shift_processor::EmptyMessage* release_getplayerstate();
  ::shift_processor::EmptyMessage* mutable_getplayerstate();
  void set_allocated_getplayerstate(::shift_processor::EmptyMessage* getplayerstate);
  private:
  const ::shift_processor::EmptyMessage& _internal_getplayerstate() const;
  ::shift_processor::EmptyMessage* _internal_mutable_getplayerstate();
  public:
  void unsafe_arena_set_allocated_getplayerstate(
      ::shift_processor::EmptyMessage* getplayerstate);
  ::shift_processor::EmptyMessage* unsafe_arena_release_getplayerstate();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:shift_processor.ShiftPlayerMessage)
 private:
  class _Internal;
  void set_has_setsequence();
  void set_has_setplaymode();
  void set_has_getplayerstate();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MessageUnion {
    constexpr MessageUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::shift_processor::SetSequenceMessage* setsequence_;
    ::shift_processor::SetPlayMode* setplaymode_;
    ::shift_processor::EmptyMessage* getplayerstate_;
  } message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_note_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class ShiftPlayerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:shift_processor.ShiftPlayerResponse) */ {
 public:
  inline ShiftPlayerResponse() : ShiftPlayerResponse(nullptr) {}
  ~ShiftPlayerResponse() override;
  explicit constexpr ShiftPlayerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShiftPlayerResponse(const ShiftPlayerResponse& from);
  ShiftPlayerResponse(ShiftPlayerResponse&& from) noexcept
    : ShiftPlayerResponse() {
    *this = ::std::move(from);
  }

  inline ShiftPlayerResponse& operator=(const ShiftPlayerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShiftPlayerResponse& operator=(ShiftPlayerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShiftPlayerResponse& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kNone = 2,
    kGetStatusData = 3,
    DATA_NOT_SET = 0,
  };

  static inline const ShiftPlayerResponse* internal_default_instance() {
    return reinterpret_cast<const ShiftPlayerResponse*>(
               &_ShiftPlayerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ShiftPlayerResponse& a, ShiftPlayerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShiftPlayerResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShiftPlayerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShiftPlayerResponse* New() const final {
    return new ShiftPlayerResponse();
  }

  ShiftPlayerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShiftPlayerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShiftPlayerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShiftPlayerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShiftPlayerResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "shift_processor.ShiftPlayerResponse";
  }
  protected:
  explicit ShiftPlayerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kNoneFieldNumber = 2,
    kGetStatusDataFieldNumber = 3,
  };
  // .shift_processor.ResponseStatus status = 1;
  void clear_status();
  ::shift_processor::ResponseStatus status() const;
  void set_status(::shift_processor::ResponseStatus value);
  private:
  ::shift_processor::ResponseStatus _internal_status() const;
  void _internal_set_status(::shift_processor::ResponseStatus value);
  public:

  // .shift_processor.EmptyMessage none = 2;
  bool has_none() const;
  private:
  bool _internal_has_none() const;
  public:
  void clear_none();
  const ::shift_processor::EmptyMessage& none() const;
  PROTOBUF_MUST_USE_RESULT ::shift_processor::EmptyMessage* release_none();
  ::shift_processor::EmptyMessage* mutable_none();
  void set_allocated_none(::shift_processor::EmptyMessage* none);
  private:
  const ::shift_processor::EmptyMessage& _internal_none() const;
  ::shift_processor::EmptyMessage* _internal_mutable_none();
  public:
  void unsafe_arena_set_allocated_none(
      ::shift_processor::EmptyMessage* none);
  ::shift_processor::EmptyMessage* unsafe_arena_release_none();

  // .shift_processor.GetStatusData getStatusData = 3;
  bool has_getstatusdata() const;
  private:
  bool _internal_has_getstatusdata() const;
  public:
  void clear_getstatusdata();
  const ::shift_processor::GetStatusData& getstatusdata() const;
  PROTOBUF_MUST_USE_RESULT ::shift_processor::GetStatusData* release_getstatusdata();
  ::shift_processor::GetStatusData* mutable_getstatusdata();
  void set_allocated_getstatusdata(::shift_processor::GetStatusData* getstatusdata);
  private:
  const ::shift_processor::GetStatusData& _internal_getstatusdata() const;
  ::shift_processor::GetStatusData* _internal_mutable_getstatusdata();
  public:
  void unsafe_arena_set_allocated_getstatusdata(
      ::shift_processor::GetStatusData* getstatusdata);
  ::shift_processor::GetStatusData* unsafe_arena_release_getstatusdata();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:shift_processor.ShiftPlayerResponse)
 private:
  class _Internal;
  void set_has_none();
  void set_has_getstatusdata();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int status_;
  union DataUnion {
    constexpr DataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::shift_processor::EmptyMessage* none_;
    ::shift_processor::GetStatusData* getstatusdata_;
  } data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_note_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class EmptyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:shift_processor.EmptyMessage) */ {
 public:
  inline EmptyMessage() : EmptyMessage(nullptr) {}
  ~EmptyMessage() override;
  explicit constexpr EmptyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyMessage(const EmptyMessage& from);
  EmptyMessage(EmptyMessage&& from) noexcept
    : EmptyMessage() {
    *this = ::std::move(from);
  }

  inline EmptyMessage& operator=(const EmptyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyMessage& operator=(EmptyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyMessage* internal_default_instance() {
    return reinterpret_cast<const EmptyMessage*>(
               &_EmptyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EmptyMessage& a, EmptyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EmptyMessage* New() const final {
    return new EmptyMessage();
  }

  EmptyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EmptyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmptyMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EmptyMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmptyMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "shift_processor.EmptyMessage";
  }
  protected:
  explicit EmptyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:shift_processor.EmptyMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_note_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class GetStatusData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:shift_processor.GetStatusData) */ {
 public:
  inline GetStatusData() : GetStatusData(nullptr) {}
  ~GetStatusData() override;
  explicit constexpr GetStatusData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStatusData(const GetStatusData& from);
  GetStatusData(GetStatusData&& from) noexcept
    : GetStatusData() {
    *this = ::std::move(from);
  }

  inline GetStatusData& operator=(const GetStatusData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStatusData& operator=(GetStatusData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStatusData& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStatusData* internal_default_instance() {
    return reinterpret_cast<const GetStatusData*>(
               &_GetStatusData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetStatusData& a, GetStatusData& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStatusData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStatusData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetStatusData* New() const final {
    return new GetStatusData();
  }

  GetStatusData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetStatusData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStatusData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetStatusData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStatusData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "shift_processor.GetStatusData";
  }
  protected:
  explicit GetStatusData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentPositionFieldNumber = 1,
  };
  // .shift_processor.SequencePosition currentPosition = 1;
  bool has_currentposition() const;
  private:
  bool _internal_has_currentposition() const;
  public:
  void clear_currentposition();
  const ::shift_processor::SequencePosition& currentposition() const;
  PROTOBUF_MUST_USE_RESULT ::shift_processor::SequencePosition* release_currentposition();
  ::shift_processor::SequencePosition* mutable_currentposition();
  void set_allocated_currentposition(::shift_processor::SequencePosition* currentposition);
  private:
  const ::shift_processor::SequencePosition& _internal_currentposition() const;
  ::shift_processor::SequencePosition* _internal_mutable_currentposition();
  public:
  void unsafe_arena_set_allocated_currentposition(
      ::shift_processor::SequencePosition* currentposition);
  ::shift_processor::SequencePosition* unsafe_arena_release_currentposition();

  // @@protoc_insertion_point(class_scope:shift_processor.GetStatusData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::shift_processor::SequencePosition* currentposition_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_note_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class SequencePosition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:shift_processor.SequencePosition) */ {
 public:
  inline SequencePosition() : SequencePosition(nullptr) {}
  ~SequencePosition() override;
  explicit constexpr SequencePosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SequencePosition(const SequencePosition& from);
  SequencePosition(SequencePosition&& from) noexcept
    : SequencePosition() {
    *this = ::std::move(from);
  }

  inline SequencePosition& operator=(const SequencePosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline SequencePosition& operator=(SequencePosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SequencePosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const SequencePosition* internal_default_instance() {
    return reinterpret_cast<const SequencePosition*>(
               &_SequencePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SequencePosition& a, SequencePosition& b) {
    a.Swap(&b);
  }
  inline void Swap(SequencePosition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SequencePosition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SequencePosition* New() const final {
    return new SequencePosition();
  }

  SequencePosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SequencePosition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SequencePosition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SequencePosition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SequencePosition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "shift_processor.SequencePosition";
  }
  protected:
  explicit SequencePosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndTimeMsFieldNumber = 1,
    kCurrentTimeMsFieldNumber = 2,
  };
  // double endTimeMs = 1;
  void clear_endtimems();
  double endtimems() const;
  void set_endtimems(double value);
  private:
  double _internal_endtimems() const;
  void _internal_set_endtimems(double value);
  public:

  // double currentTimeMs = 2;
  void clear_currenttimems();
  double currenttimems() const;
  void set_currenttimems(double value);
  private:
  double _internal_currenttimems() const;
  void _internal_set_currenttimems(double value);
  public:

  // @@protoc_insertion_point(class_scope:shift_processor.SequencePosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double endtimems_;
  double currenttimems_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_note_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class SetPlayMode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:shift_processor.SetPlayMode) */ {
 public:
  inline SetPlayMode() : SetPlayMode(nullptr) {}
  ~SetPlayMode() override;
  explicit constexpr SetPlayMode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPlayMode(const SetPlayMode& from);
  SetPlayMode(SetPlayMode&& from) noexcept
    : SetPlayMode() {
    *this = ::std::move(from);
  }

  inline SetPlayMode& operator=(const SetPlayMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPlayMode& operator=(SetPlayMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPlayMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPlayMode* internal_default_instance() {
    return reinterpret_cast<const SetPlayMode*>(
               &_SetPlayMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SetPlayMode& a, SetPlayMode& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPlayMode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPlayMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetPlayMode* New() const final {
    return new SetPlayMode();
  }

  SetPlayMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetPlayMode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetPlayMode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetPlayMode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPlayMode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "shift_processor.SetPlayMode";
  }
  protected:
  explicit SetPlayMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayModeFieldNumber = 1,
  };
  // .shift_processor.PlayMode playMode = 1;
  void clear_playmode();
  ::shift_processor::PlayMode playmode() const;
  void set_playmode(::shift_processor::PlayMode value);
  private:
  ::shift_processor::PlayMode _internal_playmode() const;
  void _internal_set_playmode(::shift_processor::PlayMode value);
  public:

  // @@protoc_insertion_point(class_scope:shift_processor.SetPlayMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int playmode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_note_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class SetSequenceMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:shift_processor.SetSequenceMessage) */ {
 public:
  inline SetSequenceMessage() : SetSequenceMessage(nullptr) {}
  ~SetSequenceMessage() override;
  explicit constexpr SetSequenceMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSequenceMessage(const SetSequenceMessage& from);
  SetSequenceMessage(SetSequenceMessage&& from) noexcept
    : SetSequenceMessage() {
    *this = ::std::move(from);
  }

  inline SetSequenceMessage& operator=(const SetSequenceMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSequenceMessage& operator=(SetSequenceMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSequenceMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSequenceMessage* internal_default_instance() {
    return reinterpret_cast<const SetSequenceMessage*>(
               &_SetSequenceMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SetSequenceMessage& a, SetSequenceMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSequenceMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSequenceMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetSequenceMessage* New() const final {
    return new SetSequenceMessage();
  }

  SetSequenceMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetSequenceMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetSequenceMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetSequenceMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetSequenceMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "shift_processor.SetSequenceMessage";
  }
  protected:
  explicit SetSequenceMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentEventsFieldNumber = 2,
    kSequenceLengthFieldNumber = 1,
  };
  // repeated .shift_processor.InstrumentEvents instrumentEvents = 2;
  int instrumentevents_size() const;
  private:
  int _internal_instrumentevents_size() const;
  public:
  void clear_instrumentevents();
  ::shift_processor::InstrumentEvents* mutable_instrumentevents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::shift_processor::InstrumentEvents >*
      mutable_instrumentevents();
  private:
  const ::shift_processor::InstrumentEvents& _internal_instrumentevents(int index) const;
  ::shift_processor::InstrumentEvents* _internal_add_instrumentevents();
  public:
  const ::shift_processor::InstrumentEvents& instrumentevents(int index) const;
  ::shift_processor::InstrumentEvents* add_instrumentevents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::shift_processor::InstrumentEvents >&
      instrumentevents() const;

  // double sequenceLength = 1;
  void clear_sequencelength();
  double sequencelength() const;
  void set_sequencelength(double value);
  private:
  double _internal_sequencelength() const;
  void _internal_set_sequencelength(double value);
  public:

  // @@protoc_insertion_point(class_scope:shift_processor.SetSequenceMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::shift_processor::InstrumentEvents > instrumentevents_;
  double sequencelength_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_note_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class InstrumentEvents final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:shift_processor.InstrumentEvents) */ {
 public:
  inline InstrumentEvents() : InstrumentEvents(nullptr) {}
  ~InstrumentEvents() override;
  explicit constexpr InstrumentEvents(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstrumentEvents(const InstrumentEvents& from);
  InstrumentEvents(InstrumentEvents&& from) noexcept
    : InstrumentEvents() {
    *this = ::std::move(from);
  }

  inline InstrumentEvents& operator=(const InstrumentEvents& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstrumentEvents& operator=(InstrumentEvents&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstrumentEvents& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstrumentEvents* internal_default_instance() {
    return reinterpret_cast<const InstrumentEvents*>(
               &_InstrumentEvents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(InstrumentEvents& a, InstrumentEvents& b) {
    a.Swap(&b);
  }
  inline void Swap(InstrumentEvents* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstrumentEvents* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InstrumentEvents* New() const final {
    return new InstrumentEvents();
  }

  InstrumentEvents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InstrumentEvents>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstrumentEvents& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InstrumentEvents& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstrumentEvents* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "shift_processor.InstrumentEvents";
  }
  protected:
  explicit InstrumentEvents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 2,
    kInstrumentFieldNumber = 1,
  };
  // repeated .shift_processor.SequenceEvent events = 2;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::shift_processor::SequenceEvent* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::shift_processor::SequenceEvent >*
      mutable_events();
  private:
  const ::shift_processor::SequenceEvent& _internal_events(int index) const;
  ::shift_processor::SequenceEvent* _internal_add_events();
  public:
  const ::shift_processor::SequenceEvent& events(int index) const;
  ::shift_processor::SequenceEvent* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::shift_processor::SequenceEvent >&
      events() const;

  // string instrument = 1;
  void clear_instrument();
  const std::string& instrument() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instrument(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instrument();
  PROTOBUF_MUST_USE_RESULT std::string* release_instrument();
  void set_allocated_instrument(std::string* instrument);
  private:
  const std::string& _internal_instrument() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instrument(const std::string& value);
  std::string* _internal_mutable_instrument();
  public:

  // @@protoc_insertion_point(class_scope:shift_processor.InstrumentEvents)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::shift_processor::SequenceEvent > events_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instrument_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_note_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class SequenceEvent_ValuesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SequenceEvent_ValuesEntry_DoNotUse, 
    std::string, ::shift_processor::EventValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SequenceEvent_ValuesEntry_DoNotUse, 
    std::string, ::shift_processor::EventValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SequenceEvent_ValuesEntry_DoNotUse();
  explicit constexpr SequenceEvent_ValuesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SequenceEvent_ValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SequenceEvent_ValuesEntry_DoNotUse& other);
  static const SequenceEvent_ValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SequenceEvent_ValuesEntry_DoNotUse*>(&_SequenceEvent_ValuesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "shift_processor.SequenceEvent.ValuesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class SequenceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:shift_processor.SequenceEvent) */ {
 public:
  inline SequenceEvent() : SequenceEvent(nullptr) {}
  ~SequenceEvent() override;
  explicit constexpr SequenceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SequenceEvent(const SequenceEvent& from);
  SequenceEvent(SequenceEvent&& from) noexcept
    : SequenceEvent() {
    *this = ::std::move(from);
  }

  inline SequenceEvent& operator=(const SequenceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SequenceEvent& operator=(SequenceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SequenceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SequenceEvent* internal_default_instance() {
    return reinterpret_cast<const SequenceEvent*>(
               &_SequenceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SequenceEvent& a, SequenceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SequenceEvent* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SequenceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SequenceEvent* New() const final {
    return new SequenceEvent();
  }

  SequenceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SequenceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SequenceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SequenceEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SequenceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "shift_processor.SequenceEvent";
  }
  protected:
  explicit SequenceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 3,
    kEventTimeFieldNumber = 1,
    kDurationFieldNumber = 2,
  };
  // map<string, .shift_processor.EventValue> values = 3;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::shift_processor::EventValue >&
      _internal_values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::shift_processor::EventValue >*
      _internal_mutable_values();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::shift_processor::EventValue >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::shift_processor::EventValue >*
      mutable_values();

  // double eventTime = 1;
  void clear_eventtime();
  double eventtime() const;
  void set_eventtime(double value);
  private:
  double _internal_eventtime() const;
  void _internal_set_eventtime(double value);
  public:

  // double duration = 2;
  void clear_duration();
  double duration() const;
  void set_duration(double value);
  private:
  double _internal_duration() const;
  void _internal_set_duration(double value);
  public:

  // @@protoc_insertion_point(class_scope:shift_processor.SequenceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SequenceEvent_ValuesEntry_DoNotUse,
      std::string, ::shift_processor::EventValue,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> values_;
  double eventtime_;
  double duration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_note_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class EventValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:shift_processor.EventValue) */ {
 public:
  inline EventValue() : EventValue(nullptr) {}
  ~EventValue() override;
  explicit constexpr EventValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventValue(const EventValue& from);
  EventValue(EventValue&& from) noexcept
    : EventValue() {
    *this = ::std::move(from);
  }

  inline EventValue& operator=(const EventValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventValue& operator=(EventValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventValue& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kNumericValue = 1,
    kStringValue = 2,
    kRangedValue = 3,
    VALUE_NOT_SET = 0,
  };

  static inline const EventValue* internal_default_instance() {
    return reinterpret_cast<const EventValue*>(
               &_EventValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EventValue& a, EventValue& b) {
    a.Swap(&b);
  }
  inline void Swap(EventValue* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EventValue* New() const final {
    return new EventValue();
  }

  EventValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EventValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EventValue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "shift_processor.EventValue";
  }
  protected:
  explicit EventValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumericValueFieldNumber = 1,
    kStringValueFieldNumber = 2,
    kRangedValueFieldNumber = 3,
  };
  // double numericValue = 1;
  bool has_numericvalue() const;
  private:
  bool _internal_has_numericvalue() const;
  public:
  void clear_numericvalue();
  double numericvalue() const;
  void set_numericvalue(double value);
  private:
  double _internal_numericvalue() const;
  void _internal_set_numericvalue(double value);
  public:

  // string stringValue = 2;
  bool has_stringvalue() const;
  private:
  bool _internal_has_stringvalue() const;
  public:
  void clear_stringvalue();
  const std::string& stringvalue() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stringvalue(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stringvalue();
  PROTOBUF_MUST_USE_RESULT std::string* release_stringvalue();
  void set_allocated_stringvalue(std::string* stringvalue);
  private:
  const std::string& _internal_stringvalue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stringvalue(const std::string& value);
  std::string* _internal_mutable_stringvalue();
  public:

  // .shift_processor.RangedValue rangedValue = 3;
  bool has_rangedvalue() const;
  private:
  bool _internal_has_rangedvalue() const;
  public:
  void clear_rangedvalue();
  const ::shift_processor::RangedValue& rangedvalue() const;
  PROTOBUF_MUST_USE_RESULT ::shift_processor::RangedValue* release_rangedvalue();
  ::shift_processor::RangedValue* mutable_rangedvalue();
  void set_allocated_rangedvalue(::shift_processor::RangedValue* rangedvalue);
  private:
  const ::shift_processor::RangedValue& _internal_rangedvalue() const;
  ::shift_processor::RangedValue* _internal_mutable_rangedvalue();
  public:
  void unsafe_arena_set_allocated_rangedvalue(
      ::shift_processor::RangedValue* rangedvalue);
  ::shift_processor::RangedValue* unsafe_arena_release_rangedvalue();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:shift_processor.EventValue)
 private:
  class _Internal;
  void set_has_numericvalue();
  void set_has_stringvalue();
  void set_has_rangedvalue();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    double numericvalue_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stringvalue_;
    ::shift_processor::RangedValue* rangedvalue_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_note_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RangedValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:shift_processor.RangedValue) */ {
 public:
  inline RangedValue() : RangedValue(nullptr) {}
  ~RangedValue() override;
  explicit constexpr RangedValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RangedValue(const RangedValue& from);
  RangedValue(RangedValue&& from) noexcept
    : RangedValue() {
    *this = ::std::move(from);
  }

  inline RangedValue& operator=(const RangedValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangedValue& operator=(RangedValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangedValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangedValue* internal_default_instance() {
    return reinterpret_cast<const RangedValue*>(
               &_RangedValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RangedValue& a, RangedValue& b) {
    a.Swap(&b);
  }
  inline void Swap(RangedValue* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangedValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RangedValue* New() const final {
    return new RangedValue();
  }

  RangedValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RangedValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RangedValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RangedValue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangedValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "shift_processor.RangedValue";
  }
  protected:
  explicit RangedValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartValueFieldNumber = 1,
    kEndValueFieldNumber = 2,
    kCurveFieldNumber = 3,
  };
  // double startValue = 1;
  void clear_startvalue();
  double startvalue() const;
  void set_startvalue(double value);
  private:
  double _internal_startvalue() const;
  void _internal_set_startvalue(double value);
  public:

  // double endValue = 2;
  void clear_endvalue();
  double endvalue() const;
  void set_endvalue(double value);
  private:
  double _internal_endvalue() const;
  void _internal_set_endvalue(double value);
  public:

  // double curve = 3;
  void clear_curve();
  double curve() const;
  void set_curve(double value);
  private:
  double _internal_curve() const;
  void _internal_set_curve(double value);
  public:

  // @@protoc_insertion_point(class_scope:shift_processor.RangedValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double startvalue_;
  double endvalue_;
  double curve_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_note_5fmessage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ShiftPlayerMessage

// .shift_processor.SetSequenceMessage setSequence = 1;
inline bool ShiftPlayerMessage::_internal_has_setsequence() const {
  return message_case() == kSetSequence;
}
inline bool ShiftPlayerMessage::has_setsequence() const {
  return _internal_has_setsequence();
}
inline void ShiftPlayerMessage::set_has_setsequence() {
  _oneof_case_[0] = kSetSequence;
}
inline void ShiftPlayerMessage::clear_setsequence() {
  if (_internal_has_setsequence()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.setsequence_;
    }
    clear_has_message();
  }
}
inline ::shift_processor::SetSequenceMessage* ShiftPlayerMessage::release_setsequence() {
  // @@protoc_insertion_point(field_release:shift_processor.ShiftPlayerMessage.setSequence)
  if (_internal_has_setsequence()) {
    clear_has_message();
      ::shift_processor::SetSequenceMessage* temp = message_.setsequence_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.setsequence_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::shift_processor::SetSequenceMessage& ShiftPlayerMessage::_internal_setsequence() const {
  return _internal_has_setsequence()
      ? *message_.setsequence_
      : reinterpret_cast< ::shift_processor::SetSequenceMessage&>(::shift_processor::_SetSequenceMessage_default_instance_);
}
inline const ::shift_processor::SetSequenceMessage& ShiftPlayerMessage::setsequence() const {
  // @@protoc_insertion_point(field_get:shift_processor.ShiftPlayerMessage.setSequence)
  return _internal_setsequence();
}
inline ::shift_processor::SetSequenceMessage* ShiftPlayerMessage::unsafe_arena_release_setsequence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:shift_processor.ShiftPlayerMessage.setSequence)
  if (_internal_has_setsequence()) {
    clear_has_message();
    ::shift_processor::SetSequenceMessage* temp = message_.setsequence_;
    message_.setsequence_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ShiftPlayerMessage::unsafe_arena_set_allocated_setsequence(::shift_processor::SetSequenceMessage* setsequence) {
  clear_message();
  if (setsequence) {
    set_has_setsequence();
    message_.setsequence_ = setsequence;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:shift_processor.ShiftPlayerMessage.setSequence)
}
inline ::shift_processor::SetSequenceMessage* ShiftPlayerMessage::_internal_mutable_setsequence() {
  if (!_internal_has_setsequence()) {
    clear_message();
    set_has_setsequence();
    message_.setsequence_ = CreateMaybeMessage< ::shift_processor::SetSequenceMessage >(GetArenaForAllocation());
  }
  return message_.setsequence_;
}
inline ::shift_processor::SetSequenceMessage* ShiftPlayerMessage::mutable_setsequence() {
  ::shift_processor::SetSequenceMessage* _msg = _internal_mutable_setsequence();
  // @@protoc_insertion_point(field_mutable:shift_processor.ShiftPlayerMessage.setSequence)
  return _msg;
}

// .shift_processor.SetPlayMode setPlayMode = 2;
inline bool ShiftPlayerMessage::_internal_has_setplaymode() const {
  return message_case() == kSetPlayMode;
}
inline bool ShiftPlayerMessage::has_setplaymode() const {
  return _internal_has_setplaymode();
}
inline void ShiftPlayerMessage::set_has_setplaymode() {
  _oneof_case_[0] = kSetPlayMode;
}
inline void ShiftPlayerMessage::clear_setplaymode() {
  if (_internal_has_setplaymode()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.setplaymode_;
    }
    clear_has_message();
  }
}
inline ::shift_processor::SetPlayMode* ShiftPlayerMessage::release_setplaymode() {
  // @@protoc_insertion_point(field_release:shift_processor.ShiftPlayerMessage.setPlayMode)
  if (_internal_has_setplaymode()) {
    clear_has_message();
      ::shift_processor::SetPlayMode* temp = message_.setplaymode_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.setplaymode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::shift_processor::SetPlayMode& ShiftPlayerMessage::_internal_setplaymode() const {
  return _internal_has_setplaymode()
      ? *message_.setplaymode_
      : reinterpret_cast< ::shift_processor::SetPlayMode&>(::shift_processor::_SetPlayMode_default_instance_);
}
inline const ::shift_processor::SetPlayMode& ShiftPlayerMessage::setplaymode() const {
  // @@protoc_insertion_point(field_get:shift_processor.ShiftPlayerMessage.setPlayMode)
  return _internal_setplaymode();
}
inline ::shift_processor::SetPlayMode* ShiftPlayerMessage::unsafe_arena_release_setplaymode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:shift_processor.ShiftPlayerMessage.setPlayMode)
  if (_internal_has_setplaymode()) {
    clear_has_message();
    ::shift_processor::SetPlayMode* temp = message_.setplaymode_;
    message_.setplaymode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ShiftPlayerMessage::unsafe_arena_set_allocated_setplaymode(::shift_processor::SetPlayMode* setplaymode) {
  clear_message();
  if (setplaymode) {
    set_has_setplaymode();
    message_.setplaymode_ = setplaymode;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:shift_processor.ShiftPlayerMessage.setPlayMode)
}
inline ::shift_processor::SetPlayMode* ShiftPlayerMessage::_internal_mutable_setplaymode() {
  if (!_internal_has_setplaymode()) {
    clear_message();
    set_has_setplaymode();
    message_.setplaymode_ = CreateMaybeMessage< ::shift_processor::SetPlayMode >(GetArenaForAllocation());
  }
  return message_.setplaymode_;
}
inline ::shift_processor::SetPlayMode* ShiftPlayerMessage::mutable_setplaymode() {
  ::shift_processor::SetPlayMode* _msg = _internal_mutable_setplaymode();
  // @@protoc_insertion_point(field_mutable:shift_processor.ShiftPlayerMessage.setPlayMode)
  return _msg;
}

// .shift_processor.EmptyMessage getPlayerState = 3;
inline bool ShiftPlayerMessage::_internal_has_getplayerstate() const {
  return message_case() == kGetPlayerState;
}
inline bool ShiftPlayerMessage::has_getplayerstate() const {
  return _internal_has_getplayerstate();
}
inline void ShiftPlayerMessage::set_has_getplayerstate() {
  _oneof_case_[0] = kGetPlayerState;
}
inline void ShiftPlayerMessage::clear_getplayerstate() {
  if (_internal_has_getplayerstate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.getplayerstate_;
    }
    clear_has_message();
  }
}
inline ::shift_processor::EmptyMessage* ShiftPlayerMessage::release_getplayerstate() {
  // @@protoc_insertion_point(field_release:shift_processor.ShiftPlayerMessage.getPlayerState)
  if (_internal_has_getplayerstate()) {
    clear_has_message();
      ::shift_processor::EmptyMessage* temp = message_.getplayerstate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.getplayerstate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::shift_processor::EmptyMessage& ShiftPlayerMessage::_internal_getplayerstate() const {
  return _internal_has_getplayerstate()
      ? *message_.getplayerstate_
      : reinterpret_cast< ::shift_processor::EmptyMessage&>(::shift_processor::_EmptyMessage_default_instance_);
}
inline const ::shift_processor::EmptyMessage& ShiftPlayerMessage::getplayerstate() const {
  // @@protoc_insertion_point(field_get:shift_processor.ShiftPlayerMessage.getPlayerState)
  return _internal_getplayerstate();
}
inline ::shift_processor::EmptyMessage* ShiftPlayerMessage::unsafe_arena_release_getplayerstate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:shift_processor.ShiftPlayerMessage.getPlayerState)
  if (_internal_has_getplayerstate()) {
    clear_has_message();
    ::shift_processor::EmptyMessage* temp = message_.getplayerstate_;
    message_.getplayerstate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ShiftPlayerMessage::unsafe_arena_set_allocated_getplayerstate(::shift_processor::EmptyMessage* getplayerstate) {
  clear_message();
  if (getplayerstate) {
    set_has_getplayerstate();
    message_.getplayerstate_ = getplayerstate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:shift_processor.ShiftPlayerMessage.getPlayerState)
}
inline ::shift_processor::EmptyMessage* ShiftPlayerMessage::_internal_mutable_getplayerstate() {
  if (!_internal_has_getplayerstate()) {
    clear_message();
    set_has_getplayerstate();
    message_.getplayerstate_ = CreateMaybeMessage< ::shift_processor::EmptyMessage >(GetArenaForAllocation());
  }
  return message_.getplayerstate_;
}
inline ::shift_processor::EmptyMessage* ShiftPlayerMessage::mutable_getplayerstate() {
  ::shift_processor::EmptyMessage* _msg = _internal_mutable_getplayerstate();
  // @@protoc_insertion_point(field_mutable:shift_processor.ShiftPlayerMessage.getPlayerState)
  return _msg;
}

inline bool ShiftPlayerMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void ShiftPlayerMessage::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline ShiftPlayerMessage::MessageCase ShiftPlayerMessage::message_case() const {
  return ShiftPlayerMessage::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ShiftPlayerResponse

// .shift_processor.ResponseStatus status = 1;
inline void ShiftPlayerResponse::clear_status() {
  status_ = 0;
}
inline ::shift_processor::ResponseStatus ShiftPlayerResponse::_internal_status() const {
  return static_cast< ::shift_processor::ResponseStatus >(status_);
}
inline ::shift_processor::ResponseStatus ShiftPlayerResponse::status() const {
  // @@protoc_insertion_point(field_get:shift_processor.ShiftPlayerResponse.status)
  return _internal_status();
}
inline void ShiftPlayerResponse::_internal_set_status(::shift_processor::ResponseStatus value) {
  
  status_ = value;
}
inline void ShiftPlayerResponse::set_status(::shift_processor::ResponseStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:shift_processor.ShiftPlayerResponse.status)
}

// .shift_processor.EmptyMessage none = 2;
inline bool ShiftPlayerResponse::_internal_has_none() const {
  return data_case() == kNone;
}
inline bool ShiftPlayerResponse::has_none() const {
  return _internal_has_none();
}
inline void ShiftPlayerResponse::set_has_none() {
  _oneof_case_[0] = kNone;
}
inline void ShiftPlayerResponse::clear_none() {
  if (_internal_has_none()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.none_;
    }
    clear_has_data();
  }
}
inline ::shift_processor::EmptyMessage* ShiftPlayerResponse::release_none() {
  // @@protoc_insertion_point(field_release:shift_processor.ShiftPlayerResponse.none)
  if (_internal_has_none()) {
    clear_has_data();
      ::shift_processor::EmptyMessage* temp = data_.none_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.none_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::shift_processor::EmptyMessage& ShiftPlayerResponse::_internal_none() const {
  return _internal_has_none()
      ? *data_.none_
      : reinterpret_cast< ::shift_processor::EmptyMessage&>(::shift_processor::_EmptyMessage_default_instance_);
}
inline const ::shift_processor::EmptyMessage& ShiftPlayerResponse::none() const {
  // @@protoc_insertion_point(field_get:shift_processor.ShiftPlayerResponse.none)
  return _internal_none();
}
inline ::shift_processor::EmptyMessage* ShiftPlayerResponse::unsafe_arena_release_none() {
  // @@protoc_insertion_point(field_unsafe_arena_release:shift_processor.ShiftPlayerResponse.none)
  if (_internal_has_none()) {
    clear_has_data();
    ::shift_processor::EmptyMessage* temp = data_.none_;
    data_.none_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ShiftPlayerResponse::unsafe_arena_set_allocated_none(::shift_processor::EmptyMessage* none) {
  clear_data();
  if (none) {
    set_has_none();
    data_.none_ = none;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:shift_processor.ShiftPlayerResponse.none)
}
inline ::shift_processor::EmptyMessage* ShiftPlayerResponse::_internal_mutable_none() {
  if (!_internal_has_none()) {
    clear_data();
    set_has_none();
    data_.none_ = CreateMaybeMessage< ::shift_processor::EmptyMessage >(GetArenaForAllocation());
  }
  return data_.none_;
}
inline ::shift_processor::EmptyMessage* ShiftPlayerResponse::mutable_none() {
  ::shift_processor::EmptyMessage* _msg = _internal_mutable_none();
  // @@protoc_insertion_point(field_mutable:shift_processor.ShiftPlayerResponse.none)
  return _msg;
}

// .shift_processor.GetStatusData getStatusData = 3;
inline bool ShiftPlayerResponse::_internal_has_getstatusdata() const {
  return data_case() == kGetStatusData;
}
inline bool ShiftPlayerResponse::has_getstatusdata() const {
  return _internal_has_getstatusdata();
}
inline void ShiftPlayerResponse::set_has_getstatusdata() {
  _oneof_case_[0] = kGetStatusData;
}
inline void ShiftPlayerResponse::clear_getstatusdata() {
  if (_internal_has_getstatusdata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.getstatusdata_;
    }
    clear_has_data();
  }
}
inline ::shift_processor::GetStatusData* ShiftPlayerResponse::release_getstatusdata() {
  // @@protoc_insertion_point(field_release:shift_processor.ShiftPlayerResponse.getStatusData)
  if (_internal_has_getstatusdata()) {
    clear_has_data();
      ::shift_processor::GetStatusData* temp = data_.getstatusdata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.getstatusdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::shift_processor::GetStatusData& ShiftPlayerResponse::_internal_getstatusdata() const {
  return _internal_has_getstatusdata()
      ? *data_.getstatusdata_
      : reinterpret_cast< ::shift_processor::GetStatusData&>(::shift_processor::_GetStatusData_default_instance_);
}
inline const ::shift_processor::GetStatusData& ShiftPlayerResponse::getstatusdata() const {
  // @@protoc_insertion_point(field_get:shift_processor.ShiftPlayerResponse.getStatusData)
  return _internal_getstatusdata();
}
inline ::shift_processor::GetStatusData* ShiftPlayerResponse::unsafe_arena_release_getstatusdata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:shift_processor.ShiftPlayerResponse.getStatusData)
  if (_internal_has_getstatusdata()) {
    clear_has_data();
    ::shift_processor::GetStatusData* temp = data_.getstatusdata_;
    data_.getstatusdata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ShiftPlayerResponse::unsafe_arena_set_allocated_getstatusdata(::shift_processor::GetStatusData* getstatusdata) {
  clear_data();
  if (getstatusdata) {
    set_has_getstatusdata();
    data_.getstatusdata_ = getstatusdata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:shift_processor.ShiftPlayerResponse.getStatusData)
}
inline ::shift_processor::GetStatusData* ShiftPlayerResponse::_internal_mutable_getstatusdata() {
  if (!_internal_has_getstatusdata()) {
    clear_data();
    set_has_getstatusdata();
    data_.getstatusdata_ = CreateMaybeMessage< ::shift_processor::GetStatusData >(GetArenaForAllocation());
  }
  return data_.getstatusdata_;
}
inline ::shift_processor::GetStatusData* ShiftPlayerResponse::mutable_getstatusdata() {
  ::shift_processor::GetStatusData* _msg = _internal_mutable_getstatusdata();
  // @@protoc_insertion_point(field_mutable:shift_processor.ShiftPlayerResponse.getStatusData)
  return _msg;
}

inline bool ShiftPlayerResponse::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void ShiftPlayerResponse::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline ShiftPlayerResponse::DataCase ShiftPlayerResponse::data_case() const {
  return ShiftPlayerResponse::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// EmptyMessage

// -------------------------------------------------------------------

// GetStatusData

// .shift_processor.SequencePosition currentPosition = 1;
inline bool GetStatusData::_internal_has_currentposition() const {
  return this != internal_default_instance() && currentposition_ != nullptr;
}
inline bool GetStatusData::has_currentposition() const {
  return _internal_has_currentposition();
}
inline void GetStatusData::clear_currentposition() {
  if (GetArenaForAllocation() == nullptr && currentposition_ != nullptr) {
    delete currentposition_;
  }
  currentposition_ = nullptr;
}
inline const ::shift_processor::SequencePosition& GetStatusData::_internal_currentposition() const {
  const ::shift_processor::SequencePosition* p = currentposition_;
  return p != nullptr ? *p : reinterpret_cast<const ::shift_processor::SequencePosition&>(
      ::shift_processor::_SequencePosition_default_instance_);
}
inline const ::shift_processor::SequencePosition& GetStatusData::currentposition() const {
  // @@protoc_insertion_point(field_get:shift_processor.GetStatusData.currentPosition)
  return _internal_currentposition();
}
inline void GetStatusData::unsafe_arena_set_allocated_currentposition(
    ::shift_processor::SequencePosition* currentposition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(currentposition_);
  }
  currentposition_ = currentposition;
  if (currentposition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:shift_processor.GetStatusData.currentPosition)
}
inline ::shift_processor::SequencePosition* GetStatusData::release_currentposition() {
  
  ::shift_processor::SequencePosition* temp = currentposition_;
  currentposition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::shift_processor::SequencePosition* GetStatusData::unsafe_arena_release_currentposition() {
  // @@protoc_insertion_point(field_release:shift_processor.GetStatusData.currentPosition)
  
  ::shift_processor::SequencePosition* temp = currentposition_;
  currentposition_ = nullptr;
  return temp;
}
inline ::shift_processor::SequencePosition* GetStatusData::_internal_mutable_currentposition() {
  
  if (currentposition_ == nullptr) {
    auto* p = CreateMaybeMessage<::shift_processor::SequencePosition>(GetArenaForAllocation());
    currentposition_ = p;
  }
  return currentposition_;
}
inline ::shift_processor::SequencePosition* GetStatusData::mutable_currentposition() {
  ::shift_processor::SequencePosition* _msg = _internal_mutable_currentposition();
  // @@protoc_insertion_point(field_mutable:shift_processor.GetStatusData.currentPosition)
  return _msg;
}
inline void GetStatusData::set_allocated_currentposition(::shift_processor::SequencePosition* currentposition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete currentposition_;
  }
  if (currentposition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::shift_processor::SequencePosition>::GetOwningArena(currentposition);
    if (message_arena != submessage_arena) {
      currentposition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, currentposition, submessage_arena);
    }
    
  } else {
    
  }
  currentposition_ = currentposition;
  // @@protoc_insertion_point(field_set_allocated:shift_processor.GetStatusData.currentPosition)
}

// -------------------------------------------------------------------

// SequencePosition

// double endTimeMs = 1;
inline void SequencePosition::clear_endtimems() {
  endtimems_ = 0;
}
inline double SequencePosition::_internal_endtimems() const {
  return endtimems_;
}
inline double SequencePosition::endtimems() const {
  // @@protoc_insertion_point(field_get:shift_processor.SequencePosition.endTimeMs)
  return _internal_endtimems();
}
inline void SequencePosition::_internal_set_endtimems(double value) {
  
  endtimems_ = value;
}
inline void SequencePosition::set_endtimems(double value) {
  _internal_set_endtimems(value);
  // @@protoc_insertion_point(field_set:shift_processor.SequencePosition.endTimeMs)
}

// double currentTimeMs = 2;
inline void SequencePosition::clear_currenttimems() {
  currenttimems_ = 0;
}
inline double SequencePosition::_internal_currenttimems() const {
  return currenttimems_;
}
inline double SequencePosition::currenttimems() const {
  // @@protoc_insertion_point(field_get:shift_processor.SequencePosition.currentTimeMs)
  return _internal_currenttimems();
}
inline void SequencePosition::_internal_set_currenttimems(double value) {
  
  currenttimems_ = value;
}
inline void SequencePosition::set_currenttimems(double value) {
  _internal_set_currenttimems(value);
  // @@protoc_insertion_point(field_set:shift_processor.SequencePosition.currentTimeMs)
}

// -------------------------------------------------------------------

// SetPlayMode

// .shift_processor.PlayMode playMode = 1;
inline void SetPlayMode::clear_playmode() {
  playmode_ = 0;
}
inline ::shift_processor::PlayMode SetPlayMode::_internal_playmode() const {
  return static_cast< ::shift_processor::PlayMode >(playmode_);
}
inline ::shift_processor::PlayMode SetPlayMode::playmode() const {
  // @@protoc_insertion_point(field_get:shift_processor.SetPlayMode.playMode)
  return _internal_playmode();
}
inline void SetPlayMode::_internal_set_playmode(::shift_processor::PlayMode value) {
  
  playmode_ = value;
}
inline void SetPlayMode::set_playmode(::shift_processor::PlayMode value) {
  _internal_set_playmode(value);
  // @@protoc_insertion_point(field_set:shift_processor.SetPlayMode.playMode)
}

// -------------------------------------------------------------------

// SetSequenceMessage

// double sequenceLength = 1;
inline void SetSequenceMessage::clear_sequencelength() {
  sequencelength_ = 0;
}
inline double SetSequenceMessage::_internal_sequencelength() const {
  return sequencelength_;
}
inline double SetSequenceMessage::sequencelength() const {
  // @@protoc_insertion_point(field_get:shift_processor.SetSequenceMessage.sequenceLength)
  return _internal_sequencelength();
}
inline void SetSequenceMessage::_internal_set_sequencelength(double value) {
  
  sequencelength_ = value;
}
inline void SetSequenceMessage::set_sequencelength(double value) {
  _internal_set_sequencelength(value);
  // @@protoc_insertion_point(field_set:shift_processor.SetSequenceMessage.sequenceLength)
}

// repeated .shift_processor.InstrumentEvents instrumentEvents = 2;
inline int SetSequenceMessage::_internal_instrumentevents_size() const {
  return instrumentevents_.size();
}
inline int SetSequenceMessage::instrumentevents_size() const {
  return _internal_instrumentevents_size();
}
inline void SetSequenceMessage::clear_instrumentevents() {
  instrumentevents_.Clear();
}
inline ::shift_processor::InstrumentEvents* SetSequenceMessage::mutable_instrumentevents(int index) {
  // @@protoc_insertion_point(field_mutable:shift_processor.SetSequenceMessage.instrumentEvents)
  return instrumentevents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::shift_processor::InstrumentEvents >*
SetSequenceMessage::mutable_instrumentevents() {
  // @@protoc_insertion_point(field_mutable_list:shift_processor.SetSequenceMessage.instrumentEvents)
  return &instrumentevents_;
}
inline const ::shift_processor::InstrumentEvents& SetSequenceMessage::_internal_instrumentevents(int index) const {
  return instrumentevents_.Get(index);
}
inline const ::shift_processor::InstrumentEvents& SetSequenceMessage::instrumentevents(int index) const {
  // @@protoc_insertion_point(field_get:shift_processor.SetSequenceMessage.instrumentEvents)
  return _internal_instrumentevents(index);
}
inline ::shift_processor::InstrumentEvents* SetSequenceMessage::_internal_add_instrumentevents() {
  return instrumentevents_.Add();
}
inline ::shift_processor::InstrumentEvents* SetSequenceMessage::add_instrumentevents() {
  ::shift_processor::InstrumentEvents* _add = _internal_add_instrumentevents();
  // @@protoc_insertion_point(field_add:shift_processor.SetSequenceMessage.instrumentEvents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::shift_processor::InstrumentEvents >&
SetSequenceMessage::instrumentevents() const {
  // @@protoc_insertion_point(field_list:shift_processor.SetSequenceMessage.instrumentEvents)
  return instrumentevents_;
}

// -------------------------------------------------------------------

// InstrumentEvents

// string instrument = 1;
inline void InstrumentEvents::clear_instrument() {
  instrument_.ClearToEmpty();
}
inline const std::string& InstrumentEvents::instrument() const {
  // @@protoc_insertion_point(field_get:shift_processor.InstrumentEvents.instrument)
  return _internal_instrument();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstrumentEvents::set_instrument(ArgT0&& arg0, ArgT... args) {
 
 instrument_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:shift_processor.InstrumentEvents.instrument)
}
inline std::string* InstrumentEvents::mutable_instrument() {
  std::string* _s = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:shift_processor.InstrumentEvents.instrument)
  return _s;
}
inline const std::string& InstrumentEvents::_internal_instrument() const {
  return instrument_.Get();
}
inline void InstrumentEvents::_internal_set_instrument(const std::string& value) {
  
  instrument_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstrumentEvents::_internal_mutable_instrument() {
  
  return instrument_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstrumentEvents::release_instrument() {
  // @@protoc_insertion_point(field_release:shift_processor.InstrumentEvents.instrument)
  return instrument_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstrumentEvents::set_allocated_instrument(std::string* instrument) {
  if (instrument != nullptr) {
    
  } else {
    
  }
  instrument_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), instrument,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:shift_processor.InstrumentEvents.instrument)
}

// repeated .shift_processor.SequenceEvent events = 2;
inline int InstrumentEvents::_internal_events_size() const {
  return events_.size();
}
inline int InstrumentEvents::events_size() const {
  return _internal_events_size();
}
inline void InstrumentEvents::clear_events() {
  events_.Clear();
}
inline ::shift_processor::SequenceEvent* InstrumentEvents::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:shift_processor.InstrumentEvents.events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::shift_processor::SequenceEvent >*
InstrumentEvents::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:shift_processor.InstrumentEvents.events)
  return &events_;
}
inline const ::shift_processor::SequenceEvent& InstrumentEvents::_internal_events(int index) const {
  return events_.Get(index);
}
inline const ::shift_processor::SequenceEvent& InstrumentEvents::events(int index) const {
  // @@protoc_insertion_point(field_get:shift_processor.InstrumentEvents.events)
  return _internal_events(index);
}
inline ::shift_processor::SequenceEvent* InstrumentEvents::_internal_add_events() {
  return events_.Add();
}
inline ::shift_processor::SequenceEvent* InstrumentEvents::add_events() {
  ::shift_processor::SequenceEvent* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:shift_processor.InstrumentEvents.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::shift_processor::SequenceEvent >&
InstrumentEvents::events() const {
  // @@protoc_insertion_point(field_list:shift_processor.InstrumentEvents.events)
  return events_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SequenceEvent

// double eventTime = 1;
inline void SequenceEvent::clear_eventtime() {
  eventtime_ = 0;
}
inline double SequenceEvent::_internal_eventtime() const {
  return eventtime_;
}
inline double SequenceEvent::eventtime() const {
  // @@protoc_insertion_point(field_get:shift_processor.SequenceEvent.eventTime)
  return _internal_eventtime();
}
inline void SequenceEvent::_internal_set_eventtime(double value) {
  
  eventtime_ = value;
}
inline void SequenceEvent::set_eventtime(double value) {
  _internal_set_eventtime(value);
  // @@protoc_insertion_point(field_set:shift_processor.SequenceEvent.eventTime)
}

// double duration = 2;
inline void SequenceEvent::clear_duration() {
  duration_ = 0;
}
inline double SequenceEvent::_internal_duration() const {
  return duration_;
}
inline double SequenceEvent::duration() const {
  // @@protoc_insertion_point(field_get:shift_processor.SequenceEvent.duration)
  return _internal_duration();
}
inline void SequenceEvent::_internal_set_duration(double value) {
  
  duration_ = value;
}
inline void SequenceEvent::set_duration(double value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:shift_processor.SequenceEvent.duration)
}

// map<string, .shift_processor.EventValue> values = 3;
inline int SequenceEvent::_internal_values_size() const {
  return values_.size();
}
inline int SequenceEvent::values_size() const {
  return _internal_values_size();
}
inline void SequenceEvent::clear_values() {
  values_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::shift_processor::EventValue >&
SequenceEvent::_internal_values() const {
  return values_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::shift_processor::EventValue >&
SequenceEvent::values() const {
  // @@protoc_insertion_point(field_map:shift_processor.SequenceEvent.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::shift_processor::EventValue >*
SequenceEvent::_internal_mutable_values() {
  return values_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::shift_processor::EventValue >*
SequenceEvent::mutable_values() {
  // @@protoc_insertion_point(field_mutable_map:shift_processor.SequenceEvent.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// EventValue

// double numericValue = 1;
inline bool EventValue::_internal_has_numericvalue() const {
  return value_case() == kNumericValue;
}
inline bool EventValue::has_numericvalue() const {
  return _internal_has_numericvalue();
}
inline void EventValue::set_has_numericvalue() {
  _oneof_case_[0] = kNumericValue;
}
inline void EventValue::clear_numericvalue() {
  if (_internal_has_numericvalue()) {
    value_.numericvalue_ = 0;
    clear_has_value();
  }
}
inline double EventValue::_internal_numericvalue() const {
  if (_internal_has_numericvalue()) {
    return value_.numericvalue_;
  }
  return 0;
}
inline void EventValue::_internal_set_numericvalue(double value) {
  if (!_internal_has_numericvalue()) {
    clear_value();
    set_has_numericvalue();
  }
  value_.numericvalue_ = value;
}
inline double EventValue::numericvalue() const {
  // @@protoc_insertion_point(field_get:shift_processor.EventValue.numericValue)
  return _internal_numericvalue();
}
inline void EventValue::set_numericvalue(double value) {
  _internal_set_numericvalue(value);
  // @@protoc_insertion_point(field_set:shift_processor.EventValue.numericValue)
}

// string stringValue = 2;
inline bool EventValue::_internal_has_stringvalue() const {
  return value_case() == kStringValue;
}
inline bool EventValue::has_stringvalue() const {
  return _internal_has_stringvalue();
}
inline void EventValue::set_has_stringvalue() {
  _oneof_case_[0] = kStringValue;
}
inline void EventValue::clear_stringvalue() {
  if (_internal_has_stringvalue()) {
    value_.stringvalue_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_value();
  }
}
inline const std::string& EventValue::stringvalue() const {
  // @@protoc_insertion_point(field_get:shift_processor.EventValue.stringValue)
  return _internal_stringvalue();
}
template <typename ArgT0, typename... ArgT>
inline void EventValue::set_stringvalue(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_stringvalue()) {
    clear_value();
    set_has_stringvalue();
    value_.stringvalue_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.stringvalue_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:shift_processor.EventValue.stringValue)
}
inline std::string* EventValue::mutable_stringvalue() {
  std::string* _s = _internal_mutable_stringvalue();
  // @@protoc_insertion_point(field_mutable:shift_processor.EventValue.stringValue)
  return _s;
}
inline const std::string& EventValue::_internal_stringvalue() const {
  if (_internal_has_stringvalue()) {
    return value_.stringvalue_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void EventValue::_internal_set_stringvalue(const std::string& value) {
  if (!_internal_has_stringvalue()) {
    clear_value();
    set_has_stringvalue();
    value_.stringvalue_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.stringvalue_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EventValue::_internal_mutable_stringvalue() {
  if (!_internal_has_stringvalue()) {
    clear_value();
    set_has_stringvalue();
    value_.stringvalue_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return value_.stringvalue_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EventValue::release_stringvalue() {
  // @@protoc_insertion_point(field_release:shift_processor.EventValue.stringValue)
  if (_internal_has_stringvalue()) {
    clear_has_value();
    return value_.stringvalue_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void EventValue::set_allocated_stringvalue(std::string* stringvalue) {
  if (has_value()) {
    clear_value();
  }
  if (stringvalue != nullptr) {
    set_has_stringvalue();
    value_.stringvalue_.UnsafeSetDefault(stringvalue);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(stringvalue);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:shift_processor.EventValue.stringValue)
}

// .shift_processor.RangedValue rangedValue = 3;
inline bool EventValue::_internal_has_rangedvalue() const {
  return value_case() == kRangedValue;
}
inline bool EventValue::has_rangedvalue() const {
  return _internal_has_rangedvalue();
}
inline void EventValue::set_has_rangedvalue() {
  _oneof_case_[0] = kRangedValue;
}
inline void EventValue::clear_rangedvalue() {
  if (_internal_has_rangedvalue()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.rangedvalue_;
    }
    clear_has_value();
  }
}
inline ::shift_processor::RangedValue* EventValue::release_rangedvalue() {
  // @@protoc_insertion_point(field_release:shift_processor.EventValue.rangedValue)
  if (_internal_has_rangedvalue()) {
    clear_has_value();
      ::shift_processor::RangedValue* temp = value_.rangedvalue_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.rangedvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::shift_processor::RangedValue& EventValue::_internal_rangedvalue() const {
  return _internal_has_rangedvalue()
      ? *value_.rangedvalue_
      : reinterpret_cast< ::shift_processor::RangedValue&>(::shift_processor::_RangedValue_default_instance_);
}
inline const ::shift_processor::RangedValue& EventValue::rangedvalue() const {
  // @@protoc_insertion_point(field_get:shift_processor.EventValue.rangedValue)
  return _internal_rangedvalue();
}
inline ::shift_processor::RangedValue* EventValue::unsafe_arena_release_rangedvalue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:shift_processor.EventValue.rangedValue)
  if (_internal_has_rangedvalue()) {
    clear_has_value();
    ::shift_processor::RangedValue* temp = value_.rangedvalue_;
    value_.rangedvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventValue::unsafe_arena_set_allocated_rangedvalue(::shift_processor::RangedValue* rangedvalue) {
  clear_value();
  if (rangedvalue) {
    set_has_rangedvalue();
    value_.rangedvalue_ = rangedvalue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:shift_processor.EventValue.rangedValue)
}
inline ::shift_processor::RangedValue* EventValue::_internal_mutable_rangedvalue() {
  if (!_internal_has_rangedvalue()) {
    clear_value();
    set_has_rangedvalue();
    value_.rangedvalue_ = CreateMaybeMessage< ::shift_processor::RangedValue >(GetArenaForAllocation());
  }
  return value_.rangedvalue_;
}
inline ::shift_processor::RangedValue* EventValue::mutable_rangedvalue() {
  ::shift_processor::RangedValue* _msg = _internal_mutable_rangedvalue();
  // @@protoc_insertion_point(field_mutable:shift_processor.EventValue.rangedValue)
  return _msg;
}

inline bool EventValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void EventValue::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline EventValue::ValueCase EventValue::value_case() const {
  return EventValue::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RangedValue

// double startValue = 1;
inline void RangedValue::clear_startvalue() {
  startvalue_ = 0;
}
inline double RangedValue::_internal_startvalue() const {
  return startvalue_;
}
inline double RangedValue::startvalue() const {
  // @@protoc_insertion_point(field_get:shift_processor.RangedValue.startValue)
  return _internal_startvalue();
}
inline void RangedValue::_internal_set_startvalue(double value) {
  
  startvalue_ = value;
}
inline void RangedValue::set_startvalue(double value) {
  _internal_set_startvalue(value);
  // @@protoc_insertion_point(field_set:shift_processor.RangedValue.startValue)
}

// double endValue = 2;
inline void RangedValue::clear_endvalue() {
  endvalue_ = 0;
}
inline double RangedValue::_internal_endvalue() const {
  return endvalue_;
}
inline double RangedValue::endvalue() const {
  // @@protoc_insertion_point(field_get:shift_processor.RangedValue.endValue)
  return _internal_endvalue();
}
inline void RangedValue::_internal_set_endvalue(double value) {
  
  endvalue_ = value;
}
inline void RangedValue::set_endvalue(double value) {
  _internal_set_endvalue(value);
  // @@protoc_insertion_point(field_set:shift_processor.RangedValue.endValue)
}

// double curve = 3;
inline void RangedValue::clear_curve() {
  curve_ = 0;
}
inline double RangedValue::_internal_curve() const {
  return curve_;
}
inline double RangedValue::curve() const {
  // @@protoc_insertion_point(field_get:shift_processor.RangedValue.curve)
  return _internal_curve();
}
inline void RangedValue::_internal_set_curve(double value) {
  
  curve_ = value;
}
inline void RangedValue::set_curve(double value) {
  _internal_set_curve(value);
  // @@protoc_insertion_point(field_set:shift_processor.RangedValue.curve)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace shift_processor

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::shift_processor::ResponseStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::shift_processor::ResponseStatus>() {
  return ::shift_processor::ResponseStatus_descriptor();
}
template <> struct is_proto_enum< ::shift_processor::PlayMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::shift_processor::PlayMode>() {
  return ::shift_processor::PlayMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_note_5fmessage_2eproto
